<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HexFiend: HFByteArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HexFiend
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="interface_h_f_byte_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HFByteArray Class Reference<div class="ingroups"><a class="el" href="group__model.html">Model</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The principal Model class for HexFiend's MVC architecture.  
 <a href="interface_h_f_byte_array.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for HFByteArray:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interface_h_f_byte_array.png" usemap="#HFByteArray_map" alt=""/>
  <map id="HFByteArray_map" name="HFByteArray_map">
<area href="interface_h_f_attributed_byte_array.html" title="An extension of HFByteArray that supports attributes. " alt="HFAttributedByteArray" shape="rect" coords="0,112,154,136"/>
<area href="interface_h_f_b_tree_byte_array.html" title="The principal efficient implementation of HFByteArray. " alt="HFBTreeByteArray" shape="rect" coords="164,112,318,136"/>
<area href="interface_h_f_full_memory_byte_array.html" title="A naive subclass of HFByteArray suitable mainly for testing. Use HFBTreeByteArray instead..." alt="HFFullMemoryByteArray" shape="rect" coords="328,112,482,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:aac315a01effd4c2c4862294b4f1d6891"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_h_f_byte_range_attribute_array.html">HFByteRangeAttributeArray</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#aac315a01effd4c2c4862294b4f1d6891">attributesForBytesInRange:</a></td></tr>
<tr class="separator:aac315a01effd4c2c4862294b4f1d6891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7df21b4d7418dcfbb5e08dd08a3d13"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_h_f_byte_range_attribute_array.html">HFByteRangeAttributeArray</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a9e7df21b4d7418dcfbb5e08dd08a3d13">byteRangeAttributeArray</a></td></tr>
<tr class="separator:a9e7df21b4d7418dcfbb5e08dd08a3d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be82f7cd32f941cc94d1843ad9ad5e8"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a9be82f7cd32f941cc94d1843ad9ad5e8">writeToFile:trackingProgress:error:</a></td></tr>
<tr class="separator:a9be82f7cd32f941cc94d1843ad9ad5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e1ab1943523b12bfd2e423ec87274a"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a44e1ab1943523b12bfd2e423ec87274a">rangesOfFileModifiedIfSavedToFile:</a></td></tr>
<tr class="separator:a44e1ab1943523b12bfd2e423ec87274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea74a3d609086f0ece0998ff96947e9"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a7ea74a3d609086f0ece0998ff96947e9">clearDependenciesOnRanges:inFile:hint:</a></td></tr>
<tr class="separator:a7ea74a3d609086f0ece0998ff96947e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization</div></td></tr>
<tr class="memitem:a0dbc26a7da687a778e0ae00d44592771"><td class="memItemLeft" align="right" valign="top">(instancetype)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a0dbc26a7da687a778e0ae00d44592771">initWithByteSlice:</a></td></tr>
<tr class="separator:a0dbc26a7da687a778e0ae00d44592771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2043a0207389099acef65b2e18ba44f7"><td class="memItemLeft" align="right" valign="top">(instancetype)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a2043a0207389099acef65b2e18ba44f7">initWithByteArray:</a></td></tr>
<tr class="separator:a2043a0207389099acef65b2e18ba44f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing raw data</div></td></tr>
<tr class="memitem:ada079f9ec02547a52439f03d03c22491"><td class="memItemLeft" align="right" valign="top">(unsigned long long)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#ada079f9ec02547a52439f03d03c22491">length</a></td></tr>
<tr class="separator:ada079f9ec02547a52439f03d03c22491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0168b2f3cedf0bd2fdf110e761ae1e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#aac0168b2f3cedf0bd2fdf110e761ae1e">copyBytes:range:</a></td></tr>
<tr class="separator:aac0168b2f3cedf0bd2fdf110e761ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing byte slices</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to access the byte slices underlying the <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a>. </p>
</div></td></tr>
<tr class="memitem:ad5bc7decb596b958f03659fecc8ab2cf"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#ad5bc7decb596b958f03659fecc8ab2cf">byteSlices</a></td></tr>
<tr class="separator:ad5bc7decb596b958f03659fecc8ab2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97980272d1583849b2ba0db9c3d28448"><td class="memItemLeft" align="right" valign="top">(NSEnumerator *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a97980272d1583849b2ba0db9c3d28448">byteSliceEnumerator</a></td></tr>
<tr class="separator:a97980272d1583849b2ba0db9c3d28448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b680933f4afc7d8b7456e9e2c025025"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a5b680933f4afc7d8b7456e9e2c025025">sliceContainingByteAtIndex:beginningOffset:</a></td></tr>
<tr class="separator:a5b680933f4afc7d8b7456e9e2c025025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying the byte array</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to modify the given byte array. </p>
</div></td></tr>
<tr class="memitem:ac1b928d1536174f41a65c54caf754011"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#ac1b928d1536174f41a65c54caf754011">insertByteSlice:inRange:</a></td></tr>
<tr class="separator:ac1b928d1536174f41a65c54caf754011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220e5b35b8ce20dfe8e2590e1e9c6f54"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a220e5b35b8ce20dfe8e2590e1e9c6f54">insertByteArray:inRange:</a></td></tr>
<tr class="separator:a220e5b35b8ce20dfe8e2590e1e9c6f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d706967a198c9ce83927aac0b1a8e53"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a2d706967a198c9ce83927aac0b1a8e53">deleteBytesInRange:</a></td></tr>
<tr class="separator:a2d706967a198c9ce83927aac0b1a8e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8cac4d751fbc61456630ee141beb64"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a6b8cac4d751fbc61456630ee141beb64">subarrayWithRange:</a></td></tr>
<tr class="separator:a6b8cac4d751fbc61456630ee141beb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Write locking and generation count</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods to lock and query the lock that prevents writes. </p>
</div></td></tr>
<tr class="memitem:a521cf2a05fdafc70b3b78c4f2bfa05ad"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a521cf2a05fdafc70b3b78c4f2bfa05ad">incrementChangeLockCounter</a></td></tr>
<tr class="separator:a521cf2a05fdafc70b3b78c4f2bfa05ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d930eebf0df5ec921678feadc84388"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a48d930eebf0df5ec921678feadc84388">decrementChangeLockCounter</a></td></tr>
<tr class="separator:a48d930eebf0df5ec921678feadc84388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b940818a34e5fc956cc05aacdd6e200"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a7b940818a34e5fc956cc05aacdd6e200">changesAreLocked</a></td></tr>
<tr class="separator:a7b940818a34e5fc956cc05aacdd6e200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac3b8df15c725a674b382b8869f0311d6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#ac3b8df15c725a674b382b8869f0311d6">incrementGenerationOrRaiseIfLockedForSelector:</a></td></tr>
<tr class="separator:ac3b8df15c725a674b382b8869f0311d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd62e6b3be8b05596494c5fbb7d7ea0f"><td class="memItemLeft" align="right" valign="top">(NSUInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#afd62e6b3be8b05596494c5fbb7d7ea0f">changeGenerationCount</a></td></tr>
<tr class="separator:afd62e6b3be8b05596494c5fbb7d7ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Searching</div></td></tr>
<tr class="memitem:a494961e16def63c7e4bcf75a342d4f68"><td class="memItemLeft" align="right" valign="top">(unsigned long long)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_h_f_byte_array.html#a494961e16def63c7e4bcf75a342d4f68">indexOfBytesEqualToBytes:inRange:searchingForwards:trackingProgress:</a></td></tr>
<tr class="separator:a494961e16def63c7e4bcf75a342d4f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> implements the Model portion of HexFiend.framework. It is logically a mutable, resizable array of bytes, with a 64 bit length. It is somewhat analagous to a 64 bit version of NSMutableData, except that it is designed to enable efficient (faster than O(n)) implementations of insertion and deletion.</p>
<p><a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a>, being an abstract class, will raise an exception if you attempt to instantiate it directly. For most uses, instantiate <a class="el" href="interface_h_f_b_tree_byte_array.html" title="The principal efficient implementation of HFByteArray. ">HFBTreeByteArray</a> instead, with the usual <code>[[class alloc] init]</code>.</p>
<p><a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> also exposes itself as an array of <a class="el" href="interface_h_f_byte_slice.html">HFByteSlices</a>, which are logically immutable arrays of bytes. which is useful for operations such as file saving that need to access the underlying byte slices.</p>
<p><a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> contains a generation count, which is incremented whenever the <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> changes (to allow caches to be implemented on top of it). It also includes the notion of locking: a locked <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> will raise an exception if written to, but it may still be read.</p>
<p>ByteArrays have the usual threading restrictions for non-concurrent data structures. It is safe to read an <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> concurrently from multiple threads. It is not safe to read an <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> while it is being modified from another thread, nor is it safe to modify one simultaneously from two threads.</p>
<p><a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> is an abstract class. It will raise an exception if you attempt to instantiate it directly. The principal concrete subclass is <a class="el" href="interface_h_f_b_tree_byte_array.html" title="The principal efficient implementation of HFByteArray. ">HFBTreeByteArray</a>. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a id="a0dbc26a7da687a778e0ae00d44592771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbc26a7da687a778e0ae00d44592771">&sect;&nbsp;</a></span>initWithByteSlice:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (instancetype) initWithByteSlice: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *)&#160;</td>
          <td class="paramname"><em>slice</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize to a byte array containing only the given slice. </p>

</div>
</div>
<a id="a2043a0207389099acef65b2e18ba44f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2043a0207389099acef65b2e18ba44f7">&sect;&nbsp;</a></span>initWithByteArray:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (instancetype) initWithByteArray: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&#160;</td>
          <td class="paramname"><em>array</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize to a byte array containing the slices of the given array. </p>

</div>
</div>
<a id="ada079f9ec02547a52439f03d03c22491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada079f9ec02547a52439f03d03c22491">&sect;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) length </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> as a 64 bit unsigned long long. This is an abstract method that concrete subclasses must override. </p>

</div>
</div>
<a id="aac0168b2f3cedf0bd2fdf110e761ae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0168b2f3cedf0bd2fdf110e761ae1e">&sect;&nbsp;</a></span>copyBytes:range:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyBytes: </td>
          <td></td>
          <td class="paramtype">(unsigned char *)&#160;</td>
          <td class="paramname"><em>dst</em></td>
        </tr>
        <tr>
          <td class="paramkey">range:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a range of bytes into a buffer. This is an abstract method that concrete subclasses must override. </p>

</div>
</div>
<a id="ad5bc7decb596b958f03659fecc8ab2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bc7decb596b958f03659fecc8ab2cf">&sect;&nbsp;</a></span>byteSlices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) byteSlices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the contents of the receiver as an array of byte slices. This is an abstract method that concrete subclasses must override. </p>

</div>
</div>
<a id="a97980272d1583849b2ba0db9c3d28448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97980272d1583849b2ba0db9c3d28448">&sect;&nbsp;</a></span>byteSliceEnumerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSEnumerator *) byteSliceEnumerator </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an NSEnumerator representing the byte slices of the receiver. This is implemented as enumerating over the result of -byteSlices, but subclasses can override this to be more efficient. </p>

</div>
</div>
<a id="a5b680933f4afc7d8b7456e9e2c025025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b680933f4afc7d8b7456e9e2c025025">&sect;&nbsp;</a></span>sliceContainingByteAtIndex:beginningOffset:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *) sliceContainingByteAtIndex: </td>
          <td></td>
          <td class="paramtype">(unsigned long long)&#160;</td>
          <td class="paramname"><em>offset</em></td>
        </tr>
        <tr>
          <td class="paramkey">beginningOffset:</td>
          <td></td>
          <td class="paramtype">(unsigned long long *)&#160;</td>
          <td class="paramname"><em>actualOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the byte slice containing the byte at the given index, and the actual offset of this slice. </p>

</div>
</div>
<a id="ac1b928d1536174f41a65c54caf754011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b928d1536174f41a65c54caf754011">&sect;&nbsp;</a></span>insertByteSlice:inRange:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) insertByteSlice: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_slice.html">HFByteSlice</a> *)&#160;</td>
          <td class="paramname"><em>slice</em></td>
        </tr>
        <tr>
          <td class="paramkey">inRange:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&#160;</td>
          <td class="paramname"><em>lrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert an <a class="el" href="interface_h_f_byte_slice.html" title="A class representing a source of data for an HFByteArray. ">HFByteSlice</a> in the given range. The maximum value of the range must not exceed the length of the subarray. The length of the given slice is not required to be equal to length of the range - in other words, this method may change the length of the receiver. This is an abstract method that concrete subclasses must override. </p>

</div>
</div>
<a id="a220e5b35b8ce20dfe8e2590e1e9c6f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220e5b35b8ce20dfe8e2590e1e9c6f54">&sect;&nbsp;</a></span>insertByteArray:inRange:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) insertByteArray: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&#160;</td>
          <td class="paramname"><em>array</em></td>
        </tr>
        <tr>
          <td class="paramkey">inRange:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&#160;</td>
          <td class="paramname"><em>lrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert an <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> in the given range. This is implemented via calling <code>insertByteSlice:inRange:</code> with the byte slices from the given byte array. </p>

</div>
</div>
<a id="a2d706967a198c9ce83927aac0b1a8e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d706967a198c9ce83927aac0b1a8e53">&sect;&nbsp;</a></span>deleteBytesInRange:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteBytesInRange: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&#160;</td>
          <td class="paramname"><em>range</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete bytes in the given range. This is implemented on the base class by creating an empty byte array and inserting it in the range to be deleted, via <code>insertByteSlice:inRange:</code>. </p>

</div>
</div>
<a id="a6b8cac4d751fbc61456630ee141beb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8cac4d751fbc61456630ee141beb64">&sect;&nbsp;</a></span>subarrayWithRange:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *) subarrayWithRange: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&#160;</td>
          <td class="paramname"><em>range</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> containing the given range. This is an abstract method that concrete subclasses must override. </p>

</div>
</div>
<a id="a521cf2a05fdafc70b3b78c4f2bfa05ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521cf2a05fdafc70b3b78c4f2bfa05ad">&sect;&nbsp;</a></span>incrementChangeLockCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) incrementChangeLockCounter </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increment the change lock. Until the change lock reaches 0, all modifications to the receiver will raise an exception. </p>

</div>
</div>
<a id="a48d930eebf0df5ec921678feadc84388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d930eebf0df5ec921678feadc84388">&sect;&nbsp;</a></span>decrementChangeLockCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) decrementChangeLockCounter </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrement the change lock. If the change lock reaches 0, modifications will be allowed again. </p>

</div>
</div>
<a id="a7b940818a34e5fc956cc05aacdd6e200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b940818a34e5fc956cc05aacdd6e200">&sect;&nbsp;</a></span>changesAreLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) changesAreLocked </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query if the changes are locked. This method is KVO compliant. </p>

</div>
</div>
<a id="ac3b8df15c725a674b382b8869f0311d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b8df15c725a674b382b8869f0311d6">&sect;&nbsp;</a></span>incrementGenerationOrRaiseIfLockedForSelector:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) incrementGenerationOrRaiseIfLockedForSelector: </td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>sel</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the generation count, unless the receiver is locked, in which case it raises an exception. All subclasses of <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> should call this method at the beginning of any overridden method that may modify the receiver. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel</td><td>The selector that would modify the receiver (e.g. <code>deleteBytesInRange:</code>). This is usually <code>_cmd</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd62e6b3be8b05596494c5fbb7d7ea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd62e6b3be8b05596494c5fbb7d7ea0f">&sect;&nbsp;</a></span>changeGenerationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSUInteger) changeGenerationCount </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the change generation count. Every change to the ByteArray increments this by one or more. This can be used for caching layers on top of <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a>, to known when to expire their cache. </p>

</div>
</div>
<a id="a494961e16def63c7e4bcf75a342d4f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494961e16def63c7e4bcf75a342d4f68">&sect;&nbsp;</a></span>indexOfBytesEqualToBytes:inRange:searchingForwards:trackingProgress:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (unsigned long long) indexOfBytesEqualToBytes: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_byte_array.html">HFByteArray</a> *)&#160;</td>
          <td class="paramname"><em>findBytes</em></td>
        </tr>
        <tr>
          <td class="paramkey">inRange:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&#160;</td>
          <td class="paramname"><em>range</em></td>
        </tr>
        <tr>
          <td class="paramkey">searchingForwards:</td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>forwards</em></td>
        </tr>
        <tr>
          <td class="paramkey">trackingProgress:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_progress_tracker.html">HFProgressTracker</a> *)&#160;</td>
          <td class="paramname"><em>progressTracker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the receiver for a byte array matching findBytes within the given range, and returns the index that it was found. This is a concrete method on <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">findBytes</td><td>The <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> containing the data to be found (the needle to the receiver's haystack). </td></tr>
    <tr><td class="paramname">range</td><td>The range of the receiver in which to search. The end of the range must not exceed the receiver's length. </td></tr>
    <tr><td class="paramname">forwards</td><td>If this is YES, then the first match within the range is returned. Otherwise the last is returned. </td></tr>
    <tr><td class="paramname">progressTracker</td><td>An <a class="el" href="interface_h_f_progress_tracker.html" title="A class that helps handle progress indication and cancellation for long running threaded operations...">HFProgressTracker</a> to allow progress reporting and cancelleation for the search operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index in the receiver of bytes equal to <code>findBytes</code>, or ULLONG_MAX if the byte array was not found (or the operation was cancelled) </dd></dl>

</div>
</div>
<a id="aac315a01effd4c2c4862294b4f1d6891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac315a01effd4c2c4862294b4f1d6891">&sect;&nbsp;</a></span>attributesForBytesInRange:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_range_attribute_array.html">HFByteRangeAttributeArray</a> *) attributesForBytesInRange: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_h_f_range.html">HFRange</a>)&#160;</td>
          <td class="paramname"><em>range</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a byte range attribute array for the bytes in the given range. </p>

<p>Provided by category <a class="el" href="category_h_f_byte_array_07_h_f_attributes_08.html#aac315a01effd4c2c4862294b4f1d6891">HFByteArray(HFAttributes)</a>.</p>

</div>
</div>
<a id="a9e7df21b4d7418dcfbb5e08dd08a3d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7df21b4d7418dcfbb5e08dd08a3d13">&sect;&nbsp;</a></span>byteRangeAttributeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_h_f_byte_range_attribute_array.html">HFByteRangeAttributeArray</a> *) byteRangeAttributeArray </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a> level byte range attribute array. Default is to return nil. </p>

<p>Provided by category <a class="el" href="category_h_f_byte_array_07_h_f_attributes_08.html#a9e7df21b4d7418dcfbb5e08dd08a3d13">HFByteArray(HFAttributes)</a>.</p>

</div>
</div>
<a id="a9be82f7cd32f941cc94d1843ad9ad5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be82f7cd32f941cc94d1843ad9ad5e8">&sect;&nbsp;</a></span>writeToFile:trackingProgress:error:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) writeToFile: </td>
          <td></td>
          <td class="paramtype">(NSURL *)&#160;</td>
          <td class="paramname"><em>targetURL</em></td>
        </tr>
        <tr>
          <td class="paramkey">trackingProgress:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_progress_tracker.html">HFProgressTracker</a> *)&#160;</td>
          <td class="paramname"><em>progressTracker</em></td>
        </tr>
        <tr>
          <td class="paramkey">error:</td>
          <td></td>
          <td class="paramtype">(NSError **)&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to write the receiver to a file. This is a concrete method on <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetURL</td><td>A URL to the file to be written to. It is OK for the receiver to contain one or more instances of <a class="el" href="interface_h_f_byte_slice.html" title="A class representing a source of data for an HFByteArray. ">HFByteSlice</a> that are sourced from the file. </td></tr>
    <tr><td class="paramname">progressTracker</td><td>An <a class="el" href="interface_h_f_progress_tracker.html" title="A class that helps handle progress indication and cancellation for long running threaded operations...">HFProgressTracker</a> to allow progress reporting and cancelleation for the write operation. </td></tr>
    <tr><td class="paramname">error</td><td>An out NSError parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>YES if the write succeeded, NO if it failed. </dd></dl>

<p>Provided by category <a class="el" href="category_h_f_byte_array_07_h_f_file_writing_08.html#a9be82f7cd32f941cc94d1843ad9ad5e8">HFByteArray(HFFileWriting)</a>.</p>

</div>
</div>
<a id="a44e1ab1943523b12bfd2e423ec87274a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e1ab1943523b12bfd2e423ec87274a">&sect;&nbsp;</a></span>rangesOfFileModifiedIfSavedToFile:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) rangesOfFileModifiedIfSavedToFile: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_file_reference.html">HFFileReference</a> *)&#160;</td>
          <td class="paramname"><em>reference</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the ranges of the file that would be modified, if the receiver were written to it. This is useful (for example) in determining if the clipboard can be preserved after a save operation. This is a concrete method on <a class="el" href="interface_h_f_byte_array.html" title="The principal Model class for HexFiend&#39;s MVC architecture. ">HFByteArray</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>An <a class="el" href="interface_h_f_file_reference.html" title="A reference to an open file. ">HFFileReference</a> to the file to be modified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of <a class="el" href="interface_h_f_range_wrapper.html">HFRangeWrappers</a>, representing the ranges of the file that would be affected. If no range would be affected, the result is an empty array. </dd></dl>

<p>Provided by category <a class="el" href="category_h_f_byte_array_07_h_f_file_writing_08.html#a44e1ab1943523b12bfd2e423ec87274a">HFByteArray(HFFileWriting)</a>.</p>

</div>
</div>
<a id="a7ea74a3d609086f0ece0998ff96947e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea74a3d609086f0ece0998ff96947e9">&sect;&nbsp;</a></span>clearDependenciesOnRanges:inFile:hint:()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) clearDependenciesOnRanges: </td>
          <td></td>
          <td class="paramtype">(NSArray *)&#160;</td>
          <td class="paramname"><em>ranges</em></td>
        </tr>
        <tr>
          <td class="paramkey">inFile:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_h_f_file_reference.html">HFFileReference</a> *)&#160;</td>
          <td class="paramname"><em>reference</em></td>
        </tr>
        <tr>
          <td class="paramkey">hint:</td>
          <td></td>
          <td class="paramtype">(NSMutableDictionary *)&#160;</td>
          <td class="paramname"><em>hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to modify the receiver so that it no longer depends on any of the HFRanges in the array within the given file. It is not necessary to perform this operation on the byte array that is being written to the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>An array of HFRangeWrappers, representing ranges in the given file that the receiver should no longer depend on. </td></tr>
    <tr><td class="paramname">reference</td><td>The <a class="el" href="interface_h_f_file_reference.html" title="A reference to an open file. ">HFFileReference</a> that the receiver should no longer depend on. </td></tr>
    <tr><td class="paramname">hint</td><td>A dictionary that can be used to improve the efficiency of the operation, by allowing multiple byte arrays to share the same state. If you plan to call this method on multiple byte arrays, pass the first one an empty NSMutableDictionary, and pass the same dictionary to subsequent calls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A YES return indicates the operation was successful, and the receiver no longer contains byte slices that source data from any of the ranges of the given file (or never did). A NO return indicates that breaking the dependencies would require too much memory, and so the receiver still depends on some of those ranges. </dd></dl>

<p>Provided by category <a class="el" href="category_h_f_byte_array_07_h_f_file_writing_08.html#a7ea74a3d609086f0ece0998ff96947e9">HFByteArray(HFFileWriting)</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_h_f_byte_array_8h_source.html">HFByteArray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
